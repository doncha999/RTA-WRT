#!/bin/bash
# /usr/bin/modemmanager-autofix
# ModemManager Auto-Fix with Traffic Monitoring
# Usage: modemmanager-autofix [start|stop|restart|status|fix-now|logs]

# Configuration
CHECK_INTERVAL=30  # Check every 30 seconds
TRAFFIC_TIMEOUT=30 # No traffic timeout in seconds
MAX_RETRIES=3      # Maximum retry attempts
RETRY_DELAY=10     # Delay between retries
PID_FILE="/var/run/modemmanager-autofix.pid"
LOG_FILE="/var/log/modemmanager-autofix.log"
TRAFFIC_LOG="/tmp/modemmanager-traffic.log"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log() {
    local type="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # Log to syslog
    logger -t "ModemManager-AutoFix" "[$type] $message"
    
    # Log to file
    echo "$timestamp [$type] $message" >> "$LOG_FILE"
    
    # Print to console if not daemon mode
    if [ "$DAEMON_MODE" != "1" ]; then
        case "$type" in
            "ERROR"|"ALERT") echo -e "${RED}[$type]${NC} $message" ;;
            "SUCCESS") echo -e "${GREEN}[$type]${NC} $message" ;;
            "WARNING") echo -e "${YELLOW}[$type]${NC} $message" ;;
            "INFO") echo -e "${BLUE}[$type]${NC} $message" ;;
            *) echo "[$type] $message" ;;
        esac
    fi
}

is_package_installed() {
    local package="$1"
    opkg list-installed | grep -q "^$package " 2>/dev/null
    return $?
}

get_modem_interface() {
    # Priority order: check UCI network config first for OpenWrt logical interfaces
    local wan_interfaces=""
    
    # Method 1: Check UCI network configuration for modem-based WAN interfaces
    if command -v uci >/dev/null 2>&1; then
        # Look for interfaces using ModemManager protocol
        for section in $(uci show network | grep "\.proto='modemmanager'" | cut -d'.' -f2 | cut -d'=' -f1 | sort -u); do
            if [ -n "$section" ]; then
                wan_interfaces="$wan_interfaces $section"
                log "DEBUG" "Found ModemManager interface in UCI: $section"
            fi
        done
        
        # Also check for other modem protocols (qmi, mbim, 3g)
        for proto in qmi mbim 3g; do
            for section in $(uci show network | grep "\.proto='$proto'" | cut -d'.' -f2 | cut -d'=' -f1 | sort -u); do
                if [ -n "$section" ]; then
                    wan_interfaces="$wan_interfaces $section"
                    log "DEBUG" "Found $proto interface in UCI: $section"
                fi
            done
        done
        
        # If no specific modem protocols found, check if 'wan' interface exists and is configured
        if [ -z "$wan_interfaces" ]; then
            if uci show network.wan >/dev/null 2>&1; then
                local wan_proto=$(uci get network.wan.proto 2>/dev/null)
                if [ -n "$wan_proto" ]; then
                    wan_interfaces="wan"
                    log "DEBUG" "Using default wan interface with protocol: $wan_proto"
                fi
            fi
        fi
    fi
    
    # Method 2: Check if these logical interfaces have corresponding network devices
    for logical_iface in $wan_interfaces; do
        # Check if interface has a physical device assigned
        local device=""
        if command -v uci >/dev/null 2>&1; then
            device=$(uci get network.${logical_iface}.device 2>/dev/null)
            if [ -z "$device" ]; then
                device=$(uci get network.${logical_iface}.ifname 2>/dev/null)
            fi
        fi
        
        # If UCI has device info, check if it exists
        if [ -n "$device" ] && ip link show "$device" >/dev/null 2>&1; then
            echo "$logical_iface"
            log "DEBUG" "Selected interface: $logical_iface (device: $device)"
            return 0
        fi
        
        # If no device specified, the logical interface might still be valid for ifup
        if [ -n "$logical_iface" ]; then
            echo "$logical_iface"
            log "DEBUG" "Selected logical interface: $logical_iface"
            return 0
        fi
    done
    
    # Method 3: Fallback to physical interface detection
    log "DEBUG" "No UCI interfaces found, falling back to physical interface detection"
    local modem_interfaces=""
    
    # Common modem interface patterns
    for iface in $(ip link show | grep -E "wwan|usb|ppp" | awk -F': ' '{print $2}' | cut -d'@' -f1); do
        if [ -n "$iface" ]; then
            modem_interfaces="$modem_interfaces $iface"
        fi
    done
    
    # Also check for interfaces from mmcli
    if command -v mmcli >/dev/null 2>&1; then
        local modem_list=$(mmcli -L 2>/dev/null | grep "Modem/" | awk '{print $1}')
        for modem in $modem_list; do
            local bearer_info=$(mmcli -m "${modem##*/}" --list-bearers 2>/dev/null)
            if [ -n "$bearer_info" ]; then
                local bearer_id=$(echo "$bearer_info" | grep "Bearer/" | awk '{print $1}' | head -1)
                if [ -n "$bearer_id" ]; then
                    local iface=$(mmcli -b "${bearer_id##*/}" 2>/dev/null | grep "interface:" | awk '{print $2}')
                    if [ -n "$iface" ]; then
                        modem_interfaces="$modem_interfaces $iface"
                    fi
                fi
            fi
        done
    fi
    
    # Return first valid physical interface
    for iface in $modem_interfaces; do
        if ip link show "$iface" >/dev/null 2>&1; then
            echo "$iface"
            log "DEBUG" "Selected physical interface: $iface"
            return 0
        fi
    done
    
    log "WARNING" "No modem interface found"
    return 1
}

get_interface_traffic() {
    local interface="$1"
    if [ -z "$interface" ]; then
        echo "0 0"
        return 1
    fi
    
    # For logical interfaces, try to find the actual physical device
    local physical_dev="$interface"
    
    # If this is a logical interface, get the physical device name
    if command -v uci >/dev/null 2>&1; then
        local uci_device=$(uci get network.${interface}.device 2>/dev/null)
        if [ -z "$uci_device" ]; then
            uci_device=$(uci get network.${interface}.ifname 2>/dev/null)
        fi
        if [ -n "$uci_device" ] && ip link show "$uci_device" >/dev/null 2>&1; then
            physical_dev="$uci_device"
        fi
    fi
    
    # Also try to find interface via ip route (for active connections)
    if [ "$physical_dev" = "$interface" ]; then
        local route_dev=$(ip route show default | grep "dev " | awk '{print $5}' | head -1)
        if [ -n "$route_dev" ] && ip link show "$route_dev" >/dev/null 2>&1; then
            physical_dev="$route_dev"
        fi
    fi
    
    # Get RX and TX bytes from /proc/net/dev
    local stats=$(grep "$physical_dev:" /proc/net/dev 2>/dev/null)
    if [ -n "$stats" ]; then
        # Extract RX bytes (field 2) and TX bytes (field 10)
        local rx_bytes=$(echo "$stats" | awk '{print $2}')
        local tx_bytes=$(echo "$stats" | awk '{print $10}')
        echo "$rx_bytes $tx_bytes"
        return 0
    fi
    
    log "DEBUG" "No traffic stats found for interface $interface (physical: $physical_dev)"
    echo "0 0"
    return 1
}

check_traffic_activity() {
    local interface="$1"
    local current_time=$(date +%s)
    
    if [ -z "$interface" ]; then
        log "WARNING" "No modem interface found for traffic monitoring"
        return 1
    fi
    
    # Get current traffic stats
    local current_stats=$(get_interface_traffic "$interface")
    local current_rx=$(echo "$current_stats" | awk '{print $1}')
    local current_tx=$(echo "$current_stats" | awk '{print $2}')
    
    # Read previous stats if available
    local prev_time=0
    local prev_rx=0
    local prev_tx=0
    
    if [ -f "$TRAFFIC_LOG" ]; then
        local prev_data=$(cat "$TRAFFIC_LOG")
        prev_time=$(echo "$prev_data" | awk '{print $1}')
        prev_rx=$(echo "$prev_data" | awk '{print $2}')
        prev_tx=$(echo "$prev_data" | awk '{print $3}')
    fi
    
    # Save current stats
    echo "$current_time $current_rx $current_tx" > "$TRAFFIC_LOG"
    
    # Check if this is first run
    if [ "$prev_time" -eq 0 ]; then
        log "INFO" "Traffic monitoring initialized for interface $interface"
        return 0
    fi
    
    # Calculate time difference
    local time_diff=$((current_time - prev_time))
    
    # Calculate traffic difference
    local rx_diff=$((current_rx - prev_rx))
    local tx_diff=$((current_tx - prev_tx))
    local total_diff=$((rx_diff + tx_diff))
    
    log "DEBUG" "Interface $interface: RX diff: $rx_diff bytes, TX diff: $tx_diff bytes, Time: ${time_diff}s"
    
    # Check if no traffic for the specified timeout period
    if [ "$total_diff" -eq 0 ] && [ "$time_diff" -ge "$TRAFFIC_TIMEOUT" ]; then
        log "WARNING" "No traffic detected on $interface for ${time_diff}s (threshold: ${TRAFFIC_TIMEOUT}s)"
        return 1
    fi
    
    return 0
}

bring_interface_up() {
    local interface="$1"
    
    if [ -z "$interface" ]; then
        log "ERROR" "No interface specified for ifup"
        return 1
    fi
    
    log "INFO" "Bringing up interface: $interface"
    
    # Method 1: Try OpenWrt network interface management (ifup)
    if command -v ifup >/dev/null 2>&1; then
        log "DEBUG" "Attempting ifup for OpenWrt logical interface: $interface"
        ifup "$interface" 2>/dev/null && {
            log "SUCCESS" "Interface $interface brought up using ifup"
            return 0
        }
    fi
    
    # Method 2: Try ubus network interface management
    if command -v ubus >/dev/null 2>&1; then
        log "DEBUG" "Attempting ubus network interface restart: $interface"
        ubus call network.interface."$interface" down 2>/dev/null
        sleep 2
        ubus call network.interface."$interface" up 2>/dev/null && {
            log "SUCCESS" "Interface $interface restarted using ubus"
            return 0
        }
    fi
    
    # Method 3: Get physical device and try ip commands
    local physical_dev="$interface"
    if command -v uci >/dev/null 2>&1; then
        local uci_device=$(uci get network.${interface}.device 2>/dev/null)
        if [ -z "$uci_device" ]; then
            uci_device=$(uci get network.${interface}.ifname 2>/dev/null)
        fi
        if [ -n "$uci_device" ]; then
            physical_dev="$uci_device"
        fi
    fi
    
    if [ "$physical_dev" != "$interface" ] && ip link show "$physical_dev" >/dev/null 2>&1; then
        log "DEBUG" "Attempting to bring up physical device: $physical_dev"
        ip link set "$physical_dev" up 2>/dev/null && {
            log "SUCCESS" "Physical device $physical_dev brought up"
            sleep 2
            
            # Try to get IP via DHCP if no IP assigned
            local has_ip=$(ip addr show "$physical_dev" | grep -c "inet ")
            if [ "$has_ip" -eq 0 ]; then
                log "INFO" "Attempting to get IP address for $physical_dev"
                if command -v udhcpc >/dev/null 2>&1; then
                    udhcpc -i "$physical_dev" -n -q 2>/dev/null &
                elif command -v dhclient >/dev/null 2>&1; then
                    dhclient "$physical_dev" 2>/dev/null &
                fi
            fi
            return 0
        }
    fi
    
    # Method 4: Try network reload (OpenWrt specific)
    if command -v /etc/init.d/network >/dev/null 2>&1; then
        log "WARNING" "Standard methods failed, attempting network reload"
        /etc/init.d/network reload 2>/dev/null && {
            log "SUCCESS" "Network reloaded successfully"
            return 0
        }
    fi
    
    # Method 5: Full network restart (last resort)
    log "WARNING" "Reload failed, attempting full network restart"
    /etc/init.d/network restart 2>/dev/null && {
        log "SUCCESS" "Network restarted successfully"
        return 0
    }
    
    log "ERROR" "Failed to bring up interface $interface"
    return 1
}

check_modem_status() {
    # Check if ModemManager is running
    if ! pgrep -f "ModemManager" > /dev/null 2>&1; then
        log "WARNING" "ModemManager process not found"
        return 1
    fi
    
    # Check if dbus is running
    if ! pgrep -f "dbus" > /dev/null 2>&1; then
        log "WARNING" "D-Bus daemon not running"
        return 1
    fi
    
    # Wait a moment for services to stabilize
    sleep 2
    
    # Check if mmcli can communicate with ModemManager
    if ! mmcli -L > /dev/null 2>&1; then
        log "WARNING" "mmcli cannot communicate with ModemManager"
        return 1
    fi
    
    # Check if any modem is available
    local modem_list=$(mmcli -L 2>/dev/null)
    local modem_count=$(echo "$modem_list" | grep -c "Modem/" 2>/dev/null || echo "0")
    
    if [ "$modem_count" -eq 0 ]; then
        log "WARNING" "No modems detected by ModemManager"
        return 1
    fi
    
    return 0
}

apply_modemmanager_fix() {
    local retry_count=0
    
    log "INFO" "Applying ModemManager fix..."
    
    while [ $retry_count -lt $MAX_RETRIES ]; do
        retry_count=$((retry_count + 1))
        log "INFO" "Fix attempt $retry_count of $MAX_RETRIES"
        
        # Kill existing ModemManager processes gracefully
        log "DEBUG" "Stopping ModemManager service..."
        /etc/init.d/modemmanager stop 2>/dev/null
        sleep 2
        
        # Force kill if still running
        pkill -f ModemManager 2>/dev/null
        sleep 1
        killall -9 ModemManager 2>/dev/null
        sleep 2
        
        # Remove stale PID and socket files
        log "DEBUG" "Cleaning up stale files..."
        rm -f /var/run/dbus.pid
        rm -f /var/run/dbus/system_bus_socket
        rm -f /var/run/ModemManager.pid
        
        # Restart D-Bus
        log "DEBUG" "Restarting D-Bus..."
        /etc/init.d/dbus restart
        sleep 3
        
        # Start ModemManager
        log "DEBUG" "Starting ModemManager..."
        /etc/init.d/modemmanager start
        sleep 5
        
        # Wait for ModemManager to initialize
        local wait_count=0
        while [ $wait_count -lt 15 ]; do
            if pgrep -f "ModemManager" > /dev/null 2>&1; then
                break
            fi
            sleep 1
            wait_count=$((wait_count + 1))
        done
        
        # Additional wait for modem detection
        sleep 10
        
        # Check if fix worked
        if check_modem_status; then
            log "SUCCESS" "ModemManager fix applied successfully (attempt $retry_count)"
            return 0
        fi
        
        if [ $retry_count -lt $MAX_RETRIES ]; then
            log "WARNING" "Fix attempt $retry_count failed, retrying in ${RETRY_DELAY}s..."
            sleep $RETRY_DELAY
        fi
    done
    
    log "ERROR" "Failed to fix ModemManager after $MAX_RETRIES attempts"
    return 1
}

is_running() {
    if [ -f "$PID_FILE" ]; then
        local pid=$(cat "$PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            return 0
        else
            rm -f "$PID_FILE"
        fi
    fi
    return 1
}

monitor_loop() {
    # Create log directory if it doesn't exist
    mkdir -p "$(dirname "$LOG_FILE")"
    
    # Write PID file
    echo $$ > "$PID_FILE"
    
    log "INFO" "Starting ModemManager monitoring loop with traffic monitoring (PID: $$, interval: ${CHECK_INTERVAL}s, traffic timeout: ${TRAFFIC_TIMEOUT}s)"
    
    # Trap signals for clean shutdown
    trap 'log "INFO" "Received shutdown signal, stopping monitor..."; rm -f "$PID_FILE" "$TRAFFIC_LOG"; exit 0' TERM INT QUIT
    
    # Initial delay to let system boot
    sleep 10
    
    while true; do
        
        # Check if ModemManager package is installed
        if ! is_package_installed "modemmanager"; then
            log "DEBUG" "ModemManager package not installed, waiting..."
            sleep 60
            continue
        fi
        
        # Get modem interface for traffic monitoring
        local modem_interface=$(get_modem_interface)
        
        # Check modem status
        local modem_status_ok=true
        if ! check_modem_status; then
            modem_status_ok=false
            log "ALERT" "Modem issue detected, applying fix..."
            if apply_modemmanager_fix; then
                log "SUCCESS" "Fix applied successfully, resuming monitoring"
                modem_status_ok=true
            else
                log "ERROR" "Fix failed, will retry on next check cycle"
            fi
        fi
        
        # Check traffic activity if modem is working
        if [ "$modem_status_ok" = true ] && [ -n "$modem_interface" ]; then
            if ! check_traffic_activity "$modem_interface"; then
                log "ALERT" "No traffic detected, attempting to bring up interface $modem_interface"
                if bring_interface_up "$modem_interface"; then
                    log "SUCCESS" "Interface recovery completed"
                    # Reset traffic log after interface recovery
                    rm -f "$TRAFFIC_LOG"
                else
                    log "ERROR" "Failed to recover interface"
                fi
            fi
        elif [ "$modem_status_ok" = true ]; then
            log "DEBUG" "No modem interface found for traffic monitoring"
        fi
        
        sleep $CHECK_INTERVAL
    done
}

start_daemon() {
    if is_running; then
        echo "ModemManager Auto-Fix is already running (PID: $(cat "$PID_FILE"))"
        return 1
    fi
    
    echo "Starting ModemManager Auto-Fix daemon with traffic monitoring..."
    export DAEMON_MODE=1
    nohup "$0" --monitor > /dev/null 2>&1 &
    
    # Wait a moment to check if it started successfully
    sleep 2
    if is_running; then
        echo "ModemManager Auto-Fix started successfully (PID: $(cat "$PID_FILE"))"
        return 0
    else
        echo "Failed to start ModemManager Auto-Fix"
        return 1
    fi
}

stop_daemon() {
    if is_running; then
        local pid=$(cat "$PID_FILE")
        echo "Stopping ModemManager Auto-Fix (PID: $pid)..."
        kill "$pid"
        
        # Wait for graceful shutdown
        local count=0
        while [ $count -lt 10 ] && kill -0 "$pid" 2>/dev/null; do
            sleep 1
            count=$((count + 1))
        done
        
        # Force kill if still running
        if kill -0 "$pid" 2>/dev/null; then
            kill -9 "$pid"
        fi
        
        rm -f "$PID_FILE" "$TRAFFIC_LOG"
        echo "ModemManager Auto-Fix stopped"
        return 0
    else
        echo "ModemManager Auto-Fix is not running"
        return 1
    fi
}

show_status() {
    if is_running; then
        local pid=$(cat "$PID_FILE")
        echo -e "${GREEN}ModemManager Auto-Fix is running${NC} (PID: $pid)"
        
        # Check modem status
        echo -n "Modem status: "
        if check_modem_status >/dev/null 2>&1; then
            echo -e "${GREEN}OK${NC}"
        else
            echo -e "${RED}PROBLEM${NC}"
        fi
        
        # Show modem interface and traffic info
        local modem_interface=$(get_modem_interface)
        if [ -n "$modem_interface" ]; then
            echo -e "Modem interface: ${BLUE}$modem_interface${NC}"
            
            # Show UCI config info if available
            if command -v uci >/dev/null 2>&1; then
                local proto=$(uci get network.${modem_interface}.proto 2>/dev/null)
                local device=$(uci get network.${modem_interface}.device 2>/dev/null)
                if [ -z "$device" ]; then
                    device=$(uci get network.${modem_interface}.ifname 2>/dev/null)
                fi
                
                if [ -n "$proto" ]; then
                    echo "Protocol: $proto"
                fi
                if [ -n "$device" ]; then
                    echo "Physical device: $device"
                fi
            fi
            
            # Show current traffic stats
            local traffic_stats=$(get_interface_traffic "$modem_interface")
            local rx_bytes=$(echo "$traffic_stats" | awk '{print $1}')
            local tx_bytes=$(echo "$traffic_stats" | awk '{print $2}')
            
            # Convert to human readable format
            local rx_mb=$((rx_bytes / 1024 / 1024))
            local tx_mb=$((tx_bytes / 1024 / 1024))
            
            echo "Traffic stats: RX: ${rx_mb}MB, TX: ${tx_mb}MB"
        else
            echo -e "Modem interface: ${YELLOW}Not found${NC}"
        fi
        
        # Show last few log entries
        echo -e "\n${BLUE}Recent log entries:${NC}"
        tail -n 5 "$LOG_FILE" 2>/dev/null || echo "No log entries found"
    else
        echo -e "${RED}ModemManager Auto-Fix is not running${NC}"
    fi
}

show_logs() {
    if [ -f "$LOG_FILE" ]; then
        if [ "$1" = "-f" ]; then
            tail -f "$LOG_FILE"
        else
            tail -n 20 "$LOG_FILE"
        fi
    else
        echo "No log file found at $LOG_FILE"
    fi
}

# Main script logic
case "$1" in
    start)
        start_daemon
        ;;
    stop)
        stop_daemon
        ;;
    restart)
        stop_daemon
        sleep 2
        start_daemon
        ;;
    status)
        show_status
        ;;
    fix-now)
        echo "Applying manual ModemManager fix..."
        if apply_modemmanager_fix; then
            echo -e "${GREEN}Fix applied successfully${NC}"
        else
            echo -e "${RED}Fix failed${NC}"
            exit 1
        fi
        ;;
    logs)
        show_logs "$2"
        ;;
    --monitor)
        # Internal use - actual monitoring loop
        monitor_loop
        ;;
    *)
        echo "Usage: $0 {start|stop|restart|status|fix-now|logs [-f]}"
        echo ""
        echo "Commands:"
        echo "  start     - Start the background monitor daemon"
        echo "  stop      - Stop the background monitor daemon"
        echo "  restart   - Restart the daemon"
        echo "  status    - Show daemon and modem status"
        echo "  fix-now   - Apply ModemManager fix manually"
        echo "  logs      - Show recent log entries"
        echo "  logs -f   - Follow log entries in real-time"
        echo ""
        echo "Features:"
        echo "  - Monitors ModemManager service health"
        echo "  - Monitors network traffic (30s timeout)"
        echo "  - Automatically restarts interfaces on no traffic"
        echo "  - Auto-recovery with configurable retry attempts"
        echo "  - OpenWrt logical interface support (wan, etc.)"
        exit 1
        ;;
esac